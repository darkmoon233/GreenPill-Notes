# 红黑树
1.二叉搜索树：任何节点的键值一定大于其左子树中的每一个节点的键值，并小于其右子树中的每一个节点的键值。
## 2.平衡二叉搜索树（没有一个节点过深）
## 3.AVL tree 任何一个节点的左右子树高度相差最多1.
## 4.红黑树：
### 4.1红黑树的规则
"叶结点" 或"NULL结点"，它不包含数据而只充当树在此结束的指示，这些结点以及它们的父结点，在绘图中都会经常被省略。
1. 每个节点非红即黑
2. 不存在两个相邻的红色节点
3. 根节点为黑
4. 任一个节点到叶节点到NULL（树尾端）的任何路径，所含的黑节点数必须相同
5. NULL节点是黑的。
### 4.2树的旋转
当树的出现深度不平衡时，就需要进行部分子树的旋转。
#### 4.2.1单旋转
在二叉平衡树的外侧插入（插入到X节点左子树的左节点，或是插入到X节点右子树的右节点）引起的平衡被破坏，通过单旋转（左旋或是右旋）可以解决

![图1](https://github.com/darkmoon233/GreenPill-Notes/raw/master/网易面试/image/leftRotate.png)


伪代码：
```
//T为二叉搜索树，x为要进行旋转的节点
Left-Rotate（T,x）
    y <- x.right                   // 对y赋值
    x.right <- y.left              // 将y的左节点赋给x做右节点（一开始y是x的右节点，最终目标是将y的左节点给x做右节点，y和x的地位互换）
    y.left.p <- x                  // 修改y的左节点的父节点为x（双（三）向赋值才算是一次完整的节点换位
    y.p <- x.p                     // 将x的父节点赋给y的父节点
    // 根据x所处的位置不同进行分类处理，x如果是根节点则根节点改为y，x如果在父节点的左（右）节点，将父节点的左（右）节点换为y节点的
    if x.p = null                
	    T.root <- y
    else if x=x.p.left
	    then x.p.left <- y
	    else x.p.right <- y
    y.left <- x
    x.p <- y
```
右旋的过程是非常像的，不多赘述。

#### 4.2.2 双旋转
在二叉平衡树的内侧插入（插入到X节点左子树的右节点，或是插入到X节点左子树的右节点）引起的平衡被破坏，通过双旋转（单旋转两次）可以解决
![双旋转](https://github.com/darkmoon233/GreenPill-Notes/raw/master/网易面试/image/leftRightRotate.png)
### 4.3红黑树的插入
#### 4.3.1二叉查找树插入
二叉查找树插入就是左右比较一下，找到位置直接插就行。(不存在插入的值已经存在的情况)
伪代码：
```
Btree-Insert(T,z)
    y <- null
    x <- T.root
    while x!= null
        do y <- x
            if x.key > z.key
                then x <- x.left
            else x <- right
    z.p <- y
    if y=null
        then z <- T.root
    else if y.key > z.key
            then y.left <- z
        else y.right <- z
```
#### 4.3.2红黑树插入和插入和插入修复
由于红黑树除了引入二叉平衡树的基础外，还引入了颜色等一系列规则，因此在调整之后需要修改。
红黑树的插入（和普通的二叉搜索树一样，只是增加了最后的涂色操作和修正操作）：
```
Rb-Insert(T,z)
    y <- null
    x <- T.root
    while x != null
        do y <- x
            if z.key < x.key
                then x <-x.left
                else x <- x.right
    z.p <- y
    if y = null
        then T.root <- z // 空树
        else if z.key < y.key
            then y.left <- z
            else y.right <- z
    z.left = null
    z.right = null
    z.color = red
    Rb-Insert-Fixup(T,z)  // 进行修正
```
分析一下插入的几种情况：
1. z没有父节点（插入的是空树），z成为红黑树的根节点，违反了根节点的颜色性质；

![](2019-03-07-22-23-27.png)
2. z的父节点为黑色，不违反性质；

![](2019-03-07-22-24-09.png)
3. z的父节点为红色，违反相邻两节点不能都为红色的性质（但这种情况必有祖父节点，且祖父必为黑色）；

![](2019-03-07-22-24-44.png)

对于情况1，直接将节点涂黑就可以了（因为不涉及到其他的规则）
对于情况2，红黑树没有被破坏，不需要进行额外的工作
对于情况3，单纯的变色不能完全解决问题，需要进行更进一步的分类。

修复红黑树的伪代码：
```
Rb-Insert-Fixup(T,z)
    while z.p.color = red
        do if z.p = z.p.p.left
            then y <- z.p.p.right
                if y.color = red                    // 情况1 ：uncle节点为红色
                    then z.p.color <- black         // 父节点重染色为黑色
                         y.color <- black           // uncle节点重染色为黑色
                         z.p.p.color <- red         // 祖父节点重染色为红色
                         z <- z.p.p                 // z指向祖父节点，重新进行染色流程（因为将祖父变色可能会带来违反红黑树规则的连锁反应）
                    else if z = z.p.right           // 情况2 ：uncle节点为黑色，且自己为父节点的右子树
                         then z <- z.p              // z指向z的父节点，以当前节点进行左旋
                              Left-Rotate(T,z)
                         z.p.color <- black         // 情况3 ：uncle节点为黑色，自己为父节点的左子树（如果是经历了左旋的话，那么z已经是左节点了）
                         z.p.p.color <- red         // 父节点染色为黑色，祖父节点染色为红色。
                         Right-Rotate(T,z.p.p)      // 以祖父节点进行右旋
            else                                    // 交换一下旋转方向
    T.root.color <- black
```
